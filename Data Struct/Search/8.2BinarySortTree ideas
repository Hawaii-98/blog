一、定义二叉树的二叉链表结点结构体
1.包含结点数据以及左右孩子指针

二、递归查找二叉排序树T中是否存在key。
0.指针f指向T的双亲，其初始调用值为NULL；
1.若查找不成功（节点为空）：
      指针p指向查找路径上访问的最后一个结点并返回FALSE；
2.若查找成功（key==T->data）：
      指针p指向该数据元素结点，并返回TRUE；
3.若需要继续查找，即(key<T->data)或者(key>T->data) ：
     在相应的左子树或者右子树中查找。
    
三、当二叉排序树T中不存在关键字等于key的数据元素时，插入key并返回TRUE，否则返回FALSE 
1.建立二叉树结点结构的临时变量p,s；
2.如果查找不成功（查找函数的返回值为零）：
      为临时变量s申请空间，数据域赋值，指针域赋空；
      考虑极端情况如果树根本没有结点（空树）此时经过查找之后p指向空，则插入s为根结点；
      如果p不为空，此时经过查找函数之后p指向查找路径上访问的最后一个结点；
            判断如果key<p的数据，则应该作为p的左儿子，否则为右儿子；
3.如果查找成功，说明树中已有关键字相同的结点，不再插入，返回FALSE。

四、从二叉排序树中删除结点p，并重接它的左或右子树。
1.建立临时变零存储树的结点；
2.如果左右子树都为空：
     令p指向空，并释放p；
3.如果右子树空则只需重接它的左子树（将左儿子挪到自己的位子上来）：
     先将p结点赋给临时变量q，让p指向他的左儿子，然后释放q；
4.如果左子树空则只需重接它的右子树（将右儿子挪到自己的位子上来）：
     先将p结点赋给临时变量q，让p指向他的右儿子，然后释放q；
5.如果左右子树都不空：
     先将p结点赋给临时变量q，让s指向他的左儿子；
     建立while循环找到待删结点的前驱：
          具体来说，就是当s的右孩子不空就一直循环，将q更新为s；s指向他的右孩子；
     此时s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值）；
     如果q结点和p结点不等，说明s有右孩子（已经成为待删除位置的元素了 ），且q指向被删节点的前驱结点的前驱，此时s的左孩子应该放到q结点的右孩子上；
     否则，说明s没有右孩子（此时s就是成为待删除位置的元素了），将s的左孩子作为删除结点位置的左孩子即可（本来就是s的左孩子，相当于s和他的左孩子一起上去了）；
     释放掉s；
     
五、若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点并返回TRUE；否则返回FALSE。
1.该函数的思路与二叉排序树的查找是一样的
2.不同在于，在查找到元素时，执行delete函数。


