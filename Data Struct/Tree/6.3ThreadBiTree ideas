一、建立一个枚举类型，包含0,1两个值
Link=0表示指向左右孩子指针,								
Thread=1表示指向前驱或后继的线索

二、建立二叉线索存储结点结构
1.包含5个元素：结点数据，左右孩子指针以及左右标志

三、前序输入二叉线索树中结点的值,构造二叉线索树T
1.思路和构造二叉树的思路是一样的，主要改动在于：
在递归构造子树之后判断当前结点是否有相应的孩子，有的话就将标志设为零

四、中序遍历进行中序线索化
0.建立一个全局变量，始终指向刚刚访问过的结点 
判断当前结点是否为空，不空则继续；
1.递归左子树线索化
2.如果当前结点没有左孩子，当前结点的前驱线索置为一，左孩子指针指向前驱
3.如果当前结点没有右孩子，则当前结点的前驱结点的后驱线索置为一，右孩子指向当前结点
4.将当前结点的值赋给pre，保持pre指向p的前驱
5.递归左子树线索化

五、带头结点的线索二叉树（中序遍历二叉树T,并将其中序线索化,Thrt指向头结点 ）
1.注意函数的参数不仅有二叉树，而且有头结点
2.为头结点申请空间，若无空间则退出程序
3.对头结点进行初始化操作：头结点的左指针标志为零，右指针标志为1，右指针回指
4.如果二叉树为空，则左指针回指
 否则：
 1.将头结点左指针指向树根；
 2.初始化pre为头结点
 3.中序遍历进行中序线索化---执行完该函数之后pre停留在树的最后一个结点
 4.让树的最后一个结点指向头结点
 5.树的最后一个结点的右指针标志置1,
 6.头结点的右孩子指向树的最后一个结点

六、中序遍历二叉线索树H(头结点)的非递归算法
1.建立临时结点p，p指向根结点
2.当不是空树或者遍历结束时（空树或遍历结束时,p==T（头结点））
  当LTag==0时，
       循环到中序序列第一个结点（就是最最左下角的结点）；
  打印结点的数据；
  当RTag==1并且右子树不是头结点时，
       循环访问后续结点
  p指向右孩子结点



