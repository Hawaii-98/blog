一、定义一个存储字符串的数组
1.注意数组的长度，预留一个位置存储数组长度

二、生成一个其值等于chars的串T
1.注意函数的输入chars是一个字符串（双引号括起来）；
2.如果chars的长度大于数组最大长度，返回提示；
3.将chars的长度存放在数组的第一个元素；
4.循环给数组T赋值；
5.打印提示，复制完毕。

三、 输出字符串T 
1.遍历输出字符串的每一个元素

四、输出next数组
1.next数组的长度即是子串的长度！
2.循环遍历输出即可，注意结合第一条指定跳出循环条件

五、朴素的模式匹配法--返回子串在主串中pos之后第一次出现的位置
1.定义临时位置变量i，j；i用于主串S中当前位置的下标值，若pos不为1，则从pos位置开始匹配，j用于子串T中当前位置下标值 ；
2.当两个临时变量都比相应串的长度小或等时，进入循环；
3.如果两字母相等，则继续比较（临时位置变量递增1）；
4.如果不等， i退回到上次匹配首位（i-j+1）的下一位（i-j+1+1）， j退回到子串T的首位 ；
5.退出循环后，判断子串是否遍历完全（遍历完全则子串临时位置变量大于子串长度）；
6.如果遍历完全，则打印此时的位置（主串临时位置变量-子串长度），
7.若遍历不完全，打印提示。

六、next数组的求解
1.定义两个指针，一个指向后缀末尾-i，一个指向前缀末尾-j；
2.初始化next数组和前缀末尾指针j；
3.当后缀指针小于子串的长度时，进入while循环--注意此处不是if语句！！
4.在while循环中：
  如果j=0或者后缀末尾和前缀末尾字符相等，则i，j递增之后给next数组赋值；
  否则前缀末尾指针j回溯至当前位置前一个元素所指的next数组的指示位置。

七、kmp算法
1.初始化主串和子串的指针，主串从pos位置开始匹配，子串从第1位置开始匹配；
2.获取T的next数组；
3.当主子串的位置指针都小于相应的串长度时，进入while循环；
 判断主子串字符是否相等，或者j是否等于0(suiran j从1开始，但是j不断返回next数组的值，有可能为0！)
 条件成立，则指针递增
 条件不成立，主串指针i不回溯！！！，j回溯至next数组的相应位置；、
4.当退出循环时，判断此时子串指针长度是否大于子串长度，若大于，说明成功匹配，返回子串的位置，否则未成功匹配。 
  
八、nextval数组的求解--对next数组的改进
    与next数组的求解基本一致，改进在于：在进入if判断之后，如果当前字符与前缀字符相同，
则将前缀字符的nextval值赋值给nextval在i位置的值。

九、改进的kmp算法--改用nextval数组返回子串指针的回溯位置




