理解一：
   文本串：aabaabaaf
   模式串：aabaaf

      当遇到冲突时（第二个b）为啥能移动到b的原因：你已经知道了f前面的字符都匹配上了
      那么1.文本串不会从第二个a开始，而是可以直接从当前的b开始
            2.模式串也不需要从第一个a开始，而是从b开始，因为知道文本串前面的一定是aa
      即:跳到b是因为第一次匹配不相等的位置之前文本串和模式串都有aa

理解二：
求最长相等前后缀，得到前缀表
aabaa 最大相等前后缀是2  不要从后反着直接读 每次都是从左往右读的

理解三：
      这个回退操作本质上是一种递推的感觉，首先知道了next[0]的回退位置，
求next[1]的操作就是，如果前后缀不同则回退，相同则更新next[1]值，这时{1]再求二
以此类推一步步更新完next数组值

理解四：
      再深入的理解：之前我们比较模式串和文本串时遇到冲突是不是回退到next数组前一位代表的下标位置，现在我们也是匹配只不过匹配的是前缀(相当于模式串)和后缀(相当于文本串)

理解五：
1.最长相等前后缀也是相当于拿前缀和后缀进行字符串匹配
2.可以注意到的是，kmp原理中，子字符串使用前缀表跳到对应位置i后






